/**
 * SOUNDANGELES DRUM SEQUENCER - COMPLETE PROFESSIONAL IMPLEMENTATION
 * Features: J Dilla Groove Engine, Pattern Banks (A,B,C,D), Copy Functions, Real Audio Samples, Cover Display
 */
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { Play, Pause, Volume2, ChevronLeft, ChevronRight, RotateCcw, Copy, Trash2, Settings, Download } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { cn } from '@/lib/utils';
import { RotaryKnob } from './RotaryKnob';
import { BlueprintOverlay, useBlueprintOverlay } from './BlueprintOverlay';
import { InstrumentWippSchalter } from './InstrumentWippSchalter';

// Import the real audio engine
import { ProfessionalAudioEngine, TrackPattern, GrooveDot } from '../audio/AudioEngine';

// Import styles
import '@/styles/soundangeles-sequencer.css';

interface SoundAngelesDrumSequencerProps {
  embedded?: boolean;
}

// Enhanced track pattern with groove support
interface EnhancedTrackPattern extends TrackPattern {
  groove: GrooveDot[]; // 16 Groove-Dots fÃ¼r jeden Step
}

// Pattern Bank structure
interface PatternBank {
  id: string;
  name: string;
  tracks: EnhancedTrackPattern[];
  bpm: number;
}

// Global quantization presets
interface QuantizationPreset {
  id: string;
  name: string;
  description: string;
}

/**
 * GROOVE UTILITIES - J Dilla Style Programming
 */

/**
 * Create default groove for a track - all steps straight (centered)
 */
const createDefaultGroove = (): GrooveDot[] => {
  return Array(16).fill(null).map((_, index) => ({
    stepIndex: index,
    offsetPercent: 0, // Straight timing
    offsetMs: 0
  }));
};

/**
 * Apply global quantization to all tracks - UNIFIED GROOVE SYSTEM
 */
const applyGlobalQuantization = (
  tracks: EnhancedTrackPattern[], 
  preset: string,
  audioEngine: ProfessionalAudioEngine
): EnhancedTrackPattern[] => {
  console.log(`ðŸŽµ Applying global quantization: ${preset.toUpperCase()}`);
  return applyGroovePreset(tracks, preset, audioEngine);
};

/**
 * Apply groove preset to all tracks
 */
const applyGroovePreset = (
  tracks: EnhancedTrackPattern[], 
  preset: string,
  audioEngine: ProfessionalAudioEngine
): EnhancedTrackPattern[] => {
  const groovePatterns: Record<string, number[]> = {
    'straight': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    'swing-light': [0, -10, 0, -10, 0, -10, 0, -10, 0, -10, 0, -10, 0, -10, 0, -10],
    'swing-medium': [0, -20, 0, -20, 0, -20, 0, -20, 0, -20, 0, -20, 0, -20, 0, -20],
    'swing-heavy': [0, -35, 0, -35, 0, -35, 0, -35, 0, -35, 0, -35, 0, -35, 0, -35],
    'shuffle': [0, -45, 0, 15, 0, -45, 0, 15, 0, -45, 0, 15, 0, -45, 0, 15],
    'j-dilla-1': [0, -25, 5, -15, 10, -30, -5, 20, 0, -20, 15, -10, -10, -35, 5, 25],
    'j-dilla-2': [5, -40, 15, -5, -10, -25, 20, -15, 10, -35, 25, 0, -20, -45, 15, 30],
    'j-dilla-3': [10, -50, 25, 5, -15, -35, 30, -10, 20, -45, 35, 15, -25, -55, 25, 40],
    'laid-back': [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
    'rushed': [-15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15],
    'funky': [0, -30, 10, -20, 5, -35, 15, -15, 0, -25, 20, -10, -5, -40, 25, 10],
    'breakbeat': [0, -20, 5, -30, 15, -15, 25, -25, 10, -35, 30, -5, 20, -45, 35, 15],
    'trap': [0, 0, -25, 0, 0, 0, -25, 0, 0, 0, -25, 0, 0, 0, -25, 0],
    'boom-bap': [0, -15, 0, -15, 10, -25, 0, -15, 0, -20, 5, -15, 0, -30, 0, -15],
    'neo-soul': [5, -35, 20, 10, -10, -45, 25, 15, 10, -30, 30, 5, -15, -50, 35, 20]
  };
  
  const selectedGroove = groovePatterns[preset] || groovePatterns['straight'];
  
  return tracks.map(track => {
    const newGroove = selectedGroove.map((offset, index) => ({
      stepIndex: index,
      offsetPercent: offset,
      offsetMs: (offset / 100) * ((60 / 120) / 4) * 0.75 * 1000 // Calculate offset in ms
    }));
    
    // Sync to audio engine
    audioEngine.updateGroove(track.id, newGroove);
    
    return { ...track, groove: newGroove };
  });
  
  console.log(`ðŸŽµ Applied groove preset: ${preset.toUpperCase()}`);
};

export default function SoundAngelesDrumSequencer({ embedded = false }: SoundAngelesDrumSequencerProps) {
  // CORE STATE - Professional drum sequencer with real samples
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [bpm, setBpm] = useState(120);
  const [masterVolume, setMasterVolume] = useState(70);
  const [currentInstrument, setCurrentInstrument] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [availablePacks, setAvailablePacks] = useState<any[]>([]);
  const [currentPackIndex, setCurrentPackIndex] = useState(0);
  
  // SAMPLE SELECTION - Track current sample index per instrument
  const [sampleIndices, setSampleIndices] = useState<number[]>(new Array(8).fill(0));
  
  // TRACK VOLUMES - Individual volume for each instrument (0-100)
  const [trackVolumes, setTrackVolumes] = useState<number[]>(new Array(8).fill(75));
  
  // BLUEPRINT OVERLAY - For pixel-perfect development
  const blueprint = useBlueprintOverlay();
  
  // PATTERN BANK SYSTEM - A, B, C, D banks with copy functionality
  const [patternBanks, setPatternBanks] = useState<PatternBank[]>([]);
  const [currentBankId, setCurrentBankId] = useState('A');
  
  // SEQUENTIAL COPY SYSTEM - Track which copy operations are allowed
  const [copyProgress, setCopyProgress] = useState({
    'A-B': false, // Aâ†’B not done yet
    'B-C': true,  // Bâ†’C disabled until Aâ†’B is done  
    'C-D': true   // Câ†’D disabled until Bâ†’C is done
  });
  
  // TRACK SYSTEM - Single row with instrument switching
  const [tracks, setTracks] = useState<EnhancedTrackPattern[]>([]);
  const [patterns, setPatterns] = useState<boolean[][]>([]);
  
  // GLOBAL QUANTIZATION SYSTEM - Applies to all instruments
  const [currentGroovePreset, setCurrentGroovePreset] = useState('straight');
  const [showGrooveControls, setShowGrooveControls] = useState(false);
  
  // Get exactly 8 instruments from pack folders - DYNAMIC from actual folder names
  const getFixedInstruments = useCallback((pack: any) => {
    if (!pack || !pack.categories) {
      // Return 8 empty slots
      return Array(8).fill(null).map((_, idx) => ({
        id: idx,
        name: '---',
        originalCategory: null,
        hasSamples: false
      }));
    }
    
    // Get actual folder names (max 8)
    const categoryKeys = Object.keys(pack.categories).slice(0, 8);
    
    // Create instruments from actual folders, pad with empty slots if < 8
    const instruments = [];
    
    for (let i = 0; i < 8; i++) {
      if (i < categoryKeys.length) {
        const categoryKey = categoryKeys[i];
        // Use REAL folder names: just remove number prefix and make uppercase
        const cleanName = categoryKey
          .replace(/^\d+[-\s]*/, '') // Remove "01-" prefix only
          .replace(/[-_]/g, ' ') // Replace dashes/underscores with spaces
          .toUpperCase() // Convert to uppercase for consistent display
          .trim();
        
        instruments.push({
          id: i,
          name: cleanName || `INST ${i + 1}`,  // Real folder names without numbers
          originalCategory: categoryKey,
          hasSamples: true
        });
      } else {
        // Empty slot
        instruments.push({
          id: i,
          name: '---',
          originalCategory: null,
          hasSamples: false
        });
      }
    }
    
    return instruments;
  }, []);
  
  // Get current instruments based on selected pack - ALWAYS 8 SLOTS
  const currentInstruments = useMemo(() => {
    if (availablePacks.length === 0) {
      // Return 8 empty slots when no packs available
      return Array(8).fill(null).map((_, idx) => ({
        id: idx,
        name: '---',
        originalCategory: null,
        hasSamples: false
      }));
    }
    const currentPack = availablePacks[currentPackIndex];
    return getFixedInstruments(currentPack);
  }, [availablePacks, currentPackIndex, getFixedInstruments]);
  
  // Color scheme matching soundangeles.com
  const colors = {
    primary: '#DB1215',      // Deep red from soundangeles
    background: '#FFFFFF',   // White background
    surface: '#F8F8F8',      // Light gray surface
    text: '#000000',         // Black text
    textMuted: '#666666',    // Muted gray text
    border: '#E0E0E0',       // Light border
    active: '#DB1215',       // Active state red
    hover: '#FF4444',        // Hover state lighter red
  };
  
  // REFS
  const audioEngineRef = useRef<ProfessionalAudioEngine>(new ProfessionalAudioEngine());
  const visualUpdateRef = useRef<number | null>(null);

  // GLOBAL QUANTIZATION - Apply to all instruments
  const handleQuantizationChange = useCallback((preset: string) => {
    setCurrentGroovePreset(preset);
    
    if (tracks.length > 0) {
      const updatedTracks = applyGlobalQuantization(tracks, preset, audioEngineRef.current);
      setTracks(updatedTracks);
      
      // Update audio engine for all tracks
      updatedTracks.forEach(track => {
        audioEngineRef.current.updateGroove(track.id, track.groove);
      });
      
      console.log(`ðŸŒ Global quantization applied: ${preset} to ${tracks.length} track(s)`);
    }
  }, [tracks]);
  
  // PATTERN BANK UTILITIES
  const initializePatternBanks = useCallback(() => {
    if (tracks.length === 0) return;
    
    const bankNames = ['A', 'B', 'C', 'D'];
    const defaultBanks: PatternBank[] = bankNames.map(name => ({
      id: name,
      name: `Bank ${name}`,
      tracks: tracks.map(track => ({
        ...track,
        steps: new Array(16).fill(false),
        groove: createDefaultGroove()
      })),
      bpm: 120
    }));
    
    setPatternBanks(defaultBanks);
    console.log('ðŸ¦ Pattern banks initialized:', bankNames);
  }, [tracks]);
  
  const saveCurrentPatternToBank = useCallback(() => {
    setPatternBanks(prev => prev.map(bank => 
      bank.id === currentBankId 
        ? {
            ...bank, 
            tracks: [...tracks],
            bpm: bpm
          }
        : bank
    ));
    console.log(`ðŸ’¾ Pattern saved to Bank ${currentBankId}`);
  }, [tracks, bpm, currentBankId]);
  
  const loadPatternFromBank = useCallback((bankId: string) => {
    const bank = patternBanks.find(b => b.id === bankId);
    if (!bank) return;
    
    // Save current pattern before switching
    if (bankId !== currentBankId) {
      saveCurrentPatternToBank();
    }
    
    // Initialize audio engine with bank tracks
    audioEngineRef.current.initializeTracks(bank.tracks);
    
    // Load bank data
    setTracks(bank.tracks);
    setBpm(bank.bpm);
    audioEngineRef.current.setBpm(bank.bpm);
    setCurrentBankId(bankId);
    
    // patterns array is not needed anymore - we read directly from tracks
    
    console.log(`ðŸ“‚ Pattern loaded from Bank ${bankId}`);
  }, [patternBanks, currentBankId, saveCurrentPatternToBank]);
  
  const copyPatternToBank = useCallback((fromBankId: string, toBankId: string) => {
    console.log(`ðŸ”„ Starting copy: ${fromBankId} â†’ ${toBankId}`);
    console.log(`ðŸ“Š Current tracks:`, tracks.map(t => ({ id: t.id, steps: t.steps.filter(s => s).length })));
    
    // Get source data IMMEDIATELY (use current live tracks if copying from current bank)
    const sourceData = fromBankId === currentBankId 
      ? { 
          tracks: tracks.map(track => ({ 
            ...track, 
            steps: [...track.steps], 
            groove: [...track.groove] 
          })), 
          bpm: bpm 
        }
      : patternBanks.find(b => b.id === fromBankId);
    
    if (!sourceData) {
      console.error(`âŒ Source bank ${fromBankId} not found`);
      return;
    }
    
    console.log(`ðŸ“Š Source data:`, sourceData.tracks.map(t => ({ id: t.id, steps: t.steps.filter(s => s).length })));
    
    // ATOMIC UPDATE: Copy data and update progress in one batch
    setPatternBanks(prev => {
      const updatedBanks = prev.map(bank => {
        if (bank.id === toBankId) {
          // Copy to target bank
          return {
            ...bank,
            tracks: sourceData.tracks.map(track => ({ 
              ...track, 
              steps: [...track.steps], 
              groove: [...track.groove] 
            })),
            bpm: sourceData.bpm
          };
        } else if (bank.id === fromBankId && fromBankId === currentBankId) {
          // Also save current state to source bank
          return {
            ...bank,
            tracks: tracks.map(track => ({ 
              ...track, 
              steps: [...track.steps], 
              groove: [...track.groove] 
            })),
            bpm: bpm
          };
        }
        return bank;
      });
      
      console.log(`âœ… Pattern banks updated`);
      return updatedBanks;
    });
    
    // Update copy progress
    const copyKey = `${fromBankId}-${toBankId}` as keyof typeof copyProgress;
    setCopyProgress(prev => {
      const newProgress = { ...prev };
      newProgress[copyKey] = true;
      
      if (copyKey === 'A-B') {
        newProgress['B-C'] = false;
      } else if (copyKey === 'B-C') {
        newProgress['C-D'] = false;
      }
      
      return newProgress;
    });
    
    // Immediately switch to target bank with the copied data
    const targetTracks = sourceData.tracks.map(track => ({ 
      ...track, 
      steps: [...track.steps], 
      groove: [...track.groove] 
    }));
    
    // Initialize audio engine
    audioEngineRef.current.initializeTracks(targetTracks);
    
    // Update React state
    setTracks(targetTracks);
    setBpm(sourceData.bpm);
    audioEngineRef.current.setBpm(sourceData.bpm);
    setCurrentBankId(toBankId);
    
    // patterns array is not needed anymore - we read directly from tracks
    
    console.log(`ðŸŽ¯ Auto-switched to Bank ${toBankId}`);
    console.log(`ðŸ“Š New tracks:`, targetTracks.map(t => ({ id: t.id, steps: t.steps.filter(s => s).length })));
    console.log(`ðŸ“‹ Copy operation completed: ${fromBankId} â†’ ${toBankId}`);
  }, [tracks, bpm, currentBankId, patternBanks, copyProgress]);
  
  const clearPatternInBank = useCallback((bankId: string) => {
    setPatternBanks(prev => prev.map(bank => 
      bank.id === bankId 
        ? {
            ...bank, 
            tracks: bank.tracks.map(track => ({
              ...track,
              steps: new Array(16).fill(false),
              groove: createDefaultGroove()
            }))
          }
        : bank
    ));
    
    // If clearing current bank, update current pattern too
    if (bankId === currentBankId) {
      const clearedTracks = tracks.map(track => ({
        ...track,
        steps: new Array(16).fill(false),
        groove: createDefaultGroove()
      }));
      setTracks(clearedTracks);
      audioEngineRef.current.initializeTracks(clearedTracks);
      // patterns array is not needed anymore - we read directly from tracks
    }
    
    console.log(`ðŸ—‘ï¸ Pattern cleared in Bank ${bankId}`);
  }, [tracks, currentBankId]);
  
  // INITIALIZATION
  useEffect(() => {
    const initializeSequencer = async () => {
      try {
        setIsLoading(true);
        
        // Define fallback pack structure FIRST (always available)
        const fallbackPacks = [
          {
            id: 'pack1',
            name: 'I.L.L. Will - Drumsound Pack Vol. 1',
            description: 'Professional drum samples',
            coverImage: '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/ILLWILL-Drum-Kit-Vol-1-1.jpg',
            categories: {
              'Kick Drums': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/01-Kick Drums/Kick Drum 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/01-Kick Drums/Kick Drum 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/01-Kick Drums/Kick Drum 3.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/01-Kick Drums/Kick Drum 4.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/01-Kick Drums/Kick Drum 5.wav'
              ] },
              'Snares': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/02-Snares/Snare 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/02-Snares/Snare 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/02-Snares/Snare 3.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/02-Snares/Snare 4.wav'
              ] },
              'Rimshot': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/03-Rimshot/Rimshot 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/03-Rimshot/Rimshot 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/03-Rimshot/Rimshot 3.wav'
              ] },
              'Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/04-Hi-hats/Hi-hat 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/04-Hi-hats/Hi-hat 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/04-Hi-hats/Hi-hat 3.wav'
              ] },
              'Open Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/05-Open hi-hats/Open Hi-hat 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/05-Open hi-hats/Open Hi-hat 2.wav'
              ] },
              'Ride': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/06-Ride/Ride 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/06-Ride/Ride 2.wav'
              ] },
              'Hand claps': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/07-Hand claps/Handclap 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/07-Hand claps/Handclap 2.wav'
              ] },
              'Percussion': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/08-Various Percussions/Perc.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 1/08-Various Percussions/Perc 2.wav'
              ] }
            }
          },
          {
            id: 'pack2',
            name: 'I.L.L. Will - Drumsound Pack Vol. 2',
            description: 'Extended drum library',
            coverImage: '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/ILLWILL-Drum-Kit-Vol-2-1.jpg',
            categories: {
              'Kick Drums': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/01-Kickdrum/Bass Drum old.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/01-Kickdrum/Bass Drum old 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/01-Kickdrum/Bass Drum old 3.wav'
              ] },
              'Snares': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/02-Snares/Snare 80s.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/02-Snares/Snare 80s 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/02-Snares/Snare 90s new jack.wav'
              ] },
              'Rimshot': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/03-Rimshots/Rimshot 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/03-Rimshots/Rimshot 2.wav'
              ] },
              'Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/04-Hi Hats/HH 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/04-Hi Hats/HH 2.wav'
              ] },
              'Open Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/05-Open Hi Hats/Ohh 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/05-Open Hi Hats/Ohh 2.wav'
              ] },
              'Ride': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/06-Ride & Crash/18AMB RI.1-S.WAV',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/06-Ride & Crash/18AMB RI.2-S.WAV'
              ] },
              'Hand claps': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/09-Handclaps/Handclap 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/09-Handclaps/Handclap 2.wav'
              ] },
              'Percussion': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/10-Percussions/Conga 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 2/10-Percussions/Cowbell.wav'
              ] }
            }
          },
          {
            id: 'pack3',
            name: 'I.L.L. Will - Drumsound Pack Vol. 3',
            description: '808 style drums',
            coverImage: '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/ILLWILL-Drum-Kit-Vol-3.jpg',
            categories: {
              'Kick Drums': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/01-Kickdrum/Bass Drum 808 long.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/01-Kickdrum/Bass Drum 808 short filter.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/01-Kickdrum/Bass Drum big shorty 10.wav'
              ] },
              'Snares': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/02-Snares/Snare 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/02-Snares/Snare 808 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/02-Snares/Snare classic 1.wav'
              ] },
              'Rimshot': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/03-Rimshots/Rimshot 808.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/03-Rimshots/Rimshot classic.wav'
              ] },
              'Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/04-Hi Hats/Hi Hat 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/04-Hi Hats/Hi Hat 808 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/04-Hi Hats/Hi Hat classic.wav'
              ] },
              'Open Hi-hats': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/05-Open Hi Hats/Open Hat 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/05-Open Hi Hats/Open Hat 808 2.wav'
              ] },
              'Ride': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/06-Ride & Crash/Crash 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/06-Ride & Crash/Crash 808 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/06-Ride & Crash/Ride 808.wav'
              ] },
              'Hand claps': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/07-Hand claps/Handclap 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/07-Hand claps/Handclap 808 2.wav'
              ] },
              'Percussion': { samples: [
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/08-Percussion/Perc 808 1.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/08-Percussion/Perc 808 2.wav',
                '/sample-packs/I.L.L. Will - Drumsound Pack Vol. 3/08-Percussion/Cowbell 808.wav'
              ] }
            }
          }
        ];
        
        // ðŸ”„ DYNAMIC SAMPLE PACK DISCOVERY - Load real sample packs from filesystem
        let discoveredPacks = [];
        try {
          console.log('ðŸ“¦ Discovering real sample packs...');
          
          // Step 1: Discover all available packs
          const packsResponse = await fetch('/api/discover-packs');
          const packsData = await packsResponse.json();
          console.log('ðŸ“¦ Found packs:', packsData.packs?.length || 0);
          
          if (packsData.packs && packsData.packs.length > 0) {
            // Step 2: For each pack, discover instruments and samples
            for (const pack of packsData.packs) {
              console.log(`ðŸ” Scanning pack: ${pack.name}`);
              
              // Get instrument folders
              const instrumentsResponse = await fetch(`/api/discover-instruments?pack=${encodeURIComponent(pack.folderName)}`);
              const instrumentsData = await instrumentsResponse.json();
              
              if (instrumentsData.folders && instrumentsData.folders.length > 0) {
                const categories = {};
                
                // Step 3: For each instrument folder, get all samples
                for (const folderName of instrumentsData.folders) {
                  console.log(`ðŸŽ¼ Scanning instrument: ${folderName}`);
                  
                  const samplesResponse = await fetch(`/api/discover-samples?pack=${encodeURIComponent(pack.folderName)}&folder=${encodeURIComponent(folderName)}`);
                  const samplesData = await samplesResponse.json();
                  
                  if (samplesData.samples && samplesData.samples.length > 0) {
                    // Convert to full paths for compatibility
                    const samplePaths = samplesData.samples.map(fileName => 
                      `/sample-packs/${pack.folderName}/${folderName}/${fileName}`
                    );
                    
                    categories[folderName] = { samples: samplePaths };
                    console.log(`âœ… Found ${samplePaths.length} samples in ${folderName}`);
                  }
                }
                
                if (Object.keys(categories).length > 0) {
                  discoveredPacks.push({
                    id: pack.id,
                    name: pack.name,
                    description: pack.description,
                    coverImage: `/sample-packs/${pack.folderName}/${pack.coverImage}`,
                    categories: categories
                  });
                  console.log(`âœ… Pack complete: ${pack.name} with ${Object.keys(categories).length} instruments`);
                }
              }
            }
          }
        } catch (discoveryError) {
          console.warn('âš ï¸ Real sample discovery failed, using fallback mode:', discoveryError.message);
        }
        
        // Use discovered packs if available, otherwise fallback
        const finalPacks = discoveredPacks.length > 0 ? discoveredPacks : fallbackPacks;
        setAvailablePacks(finalPacks);
        console.log(`ðŸ“¦ Using ${discoveredPacks.length > 0 ? 'REAL' : 'FALLBACK'} packs:`, finalPacks.length);
        
        // Create tracks based on FIXED 8 INSTRUMENTS
        const currentPack = finalPacks[0];
        const fixedInstruments = getFixedInstruments(currentPack);
        const initialTracks: EnhancedTrackPattern[] = fixedInstruments.map((instrument, index) => ({
          id: `sa_track_${index}`, // Unique ID for each instrument
          name: `${instrument.name} Track`,
          steps: new Array(16).fill(false), // Each instrument starts with empty pattern
          volume: masterVolume / 100,
          selectedSampleId: '', // Will be set when samples load
          muted: false,
          groove: createDefaultGroove()
        }));
        
        setTracks(initialTracks);
        
        // patterns array is not needed anymore - we read directly from tracks
        
        // Initialize audio engine with dynamic tracks
        audioEngineRef.current.initializeTracks(initialTracks);
        
        // Set up step callback
        audioEngineRef.current.onStepCallback = (trackId: string, sampleId: string, volume: number, time: number) => {
          audioEngineRef.current.playSample(sampleId, volume, time);
        };
        
        console.log('âœ… SoundAngeles Sequencer initialized');
        
      } catch (error) {
        console.error('âŒ Failed to initialize sequencer:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    initializeSequencer();
  }, []);
  
  // Initialize pattern banks when tracks are ready
  useEffect(() => {
    if (tracks.length > 0 && patternBanks.length === 0) {
      initializePatternBanks();
    }
  }, [tracks, patternBanks.length, initializePatternBanks]);

  // Handle volume changes without reinitializing
  useEffect(() => {
    if (tracks.length > 0) {
      // Apply master volume as multiplier to individual track volumes
      tracks.forEach((track, index) => {
        const individualVolume = trackVolumes[index] || 75;
        const masterVolumeRatio = masterVolume / 100;
        const finalVolume = (individualVolume / 100) * masterVolumeRatio;
        audioEngineRef.current.updateVolume(track.id, finalVolume);
      });
    }
  }, [masterVolume, tracks, trackVolumes]);

  // PATTERN MANIPULATION - Single row with instrument switching
  const toggleStep = useCallback((step: number) => {
    if (tracks.length === 0) {
      console.warn('âš ï¸ No tracks available for pattern manipulation');
      return;
    }
    
    // Update the track for the CURRENT instrument
    const currentTrackIndex = currentInstrument;
    
    setTracks(prev => {
      const newTracks = prev.map((track, index) => {
        if (index === currentTrackIndex) { // Current instrument's track
          const newSteps = [...track.steps];
          newSteps[step] = !newSteps[step];
          
          // Update audio engine
          audioEngineRef.current.updatePattern(track.id, step, newSteps[step]);
          
          console.log(`ðŸŽµ ${currentInstruments[currentInstrument]?.name || 'Unknown'} Step ${step + 1} toggled: ${newSteps[step] ? 'ON' : 'OFF'}`);
          
          return { ...track, steps: newSteps };
        }
        return track;
      });
      
      // patterns array sync is not needed anymore since we read directly from tracks
      
      return newTracks;
    });
  }, [tracks, currentInstrument, currentInstruments, patterns]);

  // PLAYBACK CONTROLS
  const handlePlayStop = useCallback(async () => {
    if (isPlaying) {
      audioEngineRef.current.stop();
      setIsPlaying(false);
      setCurrentStep(0);
    } else {
      saveCurrentPatternToBank(); // Auto-save before playing
      await audioEngineRef.current.start();
      setIsPlaying(true);
    }
  }, [isPlaying, saveCurrentPatternToBank]);

  // Clear current pattern
  const handleClear = useCallback(() => {
    const clearedTracks = tracks.map(track => ({
      ...track,
      steps: new Array(16).fill(false)
    }));
    
    setTracks(clearedTracks);
    
    // Clear in audio engine
    clearedTracks.forEach((track, index) => {
      track.steps.forEach((_, stepIndex) => {
        audioEngineRef.current.updatePattern(track.id, stepIndex, false);
      });
    });
    
    console.log('ðŸ§¹ Pattern cleared');
  }, [tracks]);

  // BPM Change
  const handleBpmChange = useCallback((value: number[]) => {
    const newBpm = value[0];
    setBpm(newBpm);
    audioEngineRef.current.setBpm(newBpm);
  }, []);

  // Volume Change  
  const handleVolumeChange = useCallback((volume: number) => {
    setMasterVolume(volume);
    if (audioEngineRef.current) {
      audioEngineRef.current.setMasterVolume(volume / 100);
    }
  }, []);

  // Handle track volume changes
  const handleTrackVolumeChange = useCallback((trackIndex: number, volume: number) => {
    setTrackVolumes(prev => {
      const newVolumes = [...prev];
      newVolumes[trackIndex] = volume;
      return newVolumes;
    });
    
    // Update audio engine - use updateVolume method
    if (audioEngineRef.current && tracks[trackIndex]) {
      audioEngineRef.current.updateVolume(tracks[trackIndex].id, volume / 100);
      console.log(`ðŸŽ›ï¸ Volume knob ${trackIndex + 1} (${tracks[trackIndex].name}): ${volume}% -> ${volume / 100}`);
    }
  }, [tracks]);

  // SAMPLE PACK NAVIGATION
  const handlePrevPack = useCallback(() => {
    if (availablePacks.length === 0) return;
    
    const newIndex = (currentPackIndex - 1 + availablePacks.length) % availablePacks.length;
    setCurrentPackIndex(newIndex);
    
    console.log('ðŸ“¦ Switched to pack:', availablePacks[newIndex]?.name);
  }, [availablePacks, currentPackIndex]);

  const handleNextPack = useCallback(() => {
    if (availablePacks.length === 0) return;
    
    const newIndex = (currentPackIndex + 1) % availablePacks.length;
    setCurrentPackIndex(newIndex);
    
    console.log('ðŸ“¦ Switched to pack:', availablePacks[newIndex]?.name);
  }, [availablePacks, currentPackIndex]);
  
  // INSTRUMENT SWITCHING - Load appropriate sample
  const handleInstrumentChange = useCallback(async (instrumentIndex: number) => {
    setCurrentInstrument(instrumentIndex);
    
    if (availablePacks.length === 0 || tracks.length === 0) {
      console.log(`ðŸŽ¼ Switched to ${currentInstruments[instrumentIndex]?.name} (no samples available)`);
      return;
    }
    
    const currentPack = availablePacks[currentPackIndex];
    const instrument = currentInstruments[instrumentIndex];
    
    // Find matching samples in current pack
    const currentSampleIndex = sampleIndices[instrumentIndex] || 0;
    const sampleToLoad = getSampleForInstrument(currentPack, instrument, currentSampleIndex);
    
    if (sampleToLoad && tracks.length > instrumentIndex) {
      try {
        // Load sample
        await audioEngineRef.current.loadSample(sampleToLoad);
        audioEngineRef.current.updateSelectedSample(tracks[instrumentIndex].id, sampleToLoad);
        
        // ðŸŽ›ï¸ WICHTIG: Volume nach Instrument-Wechsel synchronisieren
        const currentVolume = trackVolumes[instrumentIndex] || 75;
        audioEngineRef.current.updateVolume(tracks[instrumentIndex].id, currentVolume / 100);
        
        // Update track with new sample (for the specific instrument)
        const updatedTracks = tracks.map((track, index) => 
          index === instrumentIndex 
            ? { ...track, selectedSampleId: sampleToLoad }
            : track
        );
        
        setTracks(updatedTracks);
        
        console.log(`ðŸŽ¼ Loaded sample for ${instrument.name}: ${sampleToLoad} @ ${currentVolume}%`);
      } catch (error) {
        console.warn(`âš ï¸ Failed to load sample for ${instrument.name}:`, error.message);
      }
    } else {
      console.log(`ðŸŽ¼ Switched to ${instrument.name} (no matching samples found)`);
    }
  }, [availablePacks, currentPackIndex, currentInstruments, tracks]);
  
  // Get sample path for instrument from current pack with sample index
  const getSampleForInstrument = (pack: any, instrument: any, sampleIndex: number = 0): string => {
    if (!pack?.categories || !instrument.originalCategory) return '';
    
    // Use the originalCategory that was mapped during getFixedInstruments
    const categoryKey = instrument.originalCategory;
    
    if (categoryKey && pack.categories[categoryKey]?.samples?.length > 0) {
      const validIndex = Math.min(sampleIndex, pack.categories[categoryKey].samples.length - 1);
      return pack.categories[categoryKey].samples[validIndex]; // Sample at index
    }
    
    return '';
  };
  
  // SAMPLE CYCLING - Navigate through samples for current instrument
  // Load sample for specific instrument index
  const loadSampleForInstrument = useCallback(async (instrumentIndex: number, sampleIndex: number) => {
    if (availablePacks.length === 0 || !tracks[instrumentIndex]) return;
    
    const currentPack = availablePacks[currentPackIndex];
    const instrument = currentInstruments[instrumentIndex];
    
    const sampleToLoad = getSampleForInstrument(currentPack, instrument, sampleIndex);
    if (sampleToLoad) {
      try {
        await audioEngineRef.current.loadSample(sampleToLoad);
        audioEngineRef.current.updateSelectedSample(tracks[instrumentIndex].id, sampleToLoad);
        
        // ðŸŽ›ï¸ WICHTIG: Volume nach Sample-Wechsel synchronisieren
        const currentVolume = trackVolumes[instrumentIndex] || 75;
        audioEngineRef.current.updateVolume(tracks[instrumentIndex].id, currentVolume / 100);
        
        // Update track data
        setTracks(prev => prev.map((track, index) => 
          index === instrumentIndex 
            ? { ...track, selectedSampleId: sampleToLoad }
            : track
        ));
        
        console.log(`ðŸŽ¼ Loaded sample for ${instrument.name}: ${sampleToLoad.split('/').pop()} @ ${currentVolume}%`);
      } catch (error) {
        console.error(`âŒ Failed to load sample for ${instrument.name}:`, error);
      }
    }
  }, [availablePacks, currentPackIndex, currentInstruments, tracks]);

  // Sample Navigation fÃ¼r WippSchalter
  const handlePreviousSample = useCallback((instrumentIndex: number) => {
    const instrument = currentInstruments[instrumentIndex];
    if (!instrument?.hasSamples) return;

    const currentPack = availablePacks[currentPackIndex];
    const samples = currentPack?.categories?.[instrument.originalCategory]?.samples || [];
    if (samples.length <= 1) return;

    console.log(`â¬…ï¸ BEFORE - ${instrument.name} sampleIndex: ${sampleIndices[instrumentIndex]}, samples.length: ${samples.length}`);

    const newSampleIndex = (sampleIndices[instrumentIndex] - 1 + samples.length) % samples.length;
    
    setSampleIndices(prev => {
      const newIndices = [...prev];
      newIndices[instrumentIndex] = newSampleIndex;
      console.log(`â¬…ï¸ AFTER - ${instrument.name} sampleIndex: ${newSampleIndex}`);
      return newIndices;
    });

    // Load new sample
    const sampleToLoad = samples[newSampleIndex];
    console.log(`â¬…ï¸ Loading sample: ${sampleToLoad?.split('/').pop()}`);
    
    if (sampleToLoad && tracks.length > instrumentIndex) {
      audioEngineRef.current.loadSample(sampleToLoad).then(() => {
        audioEngineRef.current.updateSelectedSample(tracks[instrumentIndex].id, sampleToLoad);
        
        // ðŸŽ›ï¸ WICHTIG: Volume nach Sample-Wechsel synchronisieren
        const currentVolume = trackVolumes[instrumentIndex] || 75;
        audioEngineRef.current.updateVolume(tracks[instrumentIndex].id, currentVolume / 100);
        
        setTracks(prev => prev.map((track, index) => 
          index === instrumentIndex 
            ? { ...track, selectedSampleId: sampleToLoad }
            : track
        ));
        console.log(`â¬…ï¸ Previous sample for ${instrument.name}: ${sampleToLoad.split('/').pop()} @ ${currentVolume}%`);
      }).catch(error => {
        console.error(`âŒ Failed to load previous sample:`, error);
      });
    }
  }, [availablePacks, currentPackIndex, currentInstruments, sampleIndices, tracks]);

  const handleNextSample = useCallback((instrumentIndex: number) => {
    const instrument = currentInstruments[instrumentIndex];
    if (!instrument?.hasSamples) return;

    const currentPack = availablePacks[currentPackIndex];
    const samples = currentPack?.categories?.[instrument.originalCategory]?.samples || [];
    if (samples.length <= 1) return;

    console.log(`âž¡ï¸ BEFORE - ${instrument.name} sampleIndex: ${sampleIndices[instrumentIndex]}, samples.length: ${samples.length}`);

    const newSampleIndex = (sampleIndices[instrumentIndex] + 1) % samples.length;
    
    setSampleIndices(prev => {
      const newIndices = [...prev];
      newIndices[instrumentIndex] = newSampleIndex;
      console.log(`âž¡ï¸ AFTER - ${instrument.name} sampleIndex: ${newSampleIndex}`);
      return newIndices;
    });

    // Load new sample
    const sampleToLoad = samples[newSampleIndex];
    console.log(`âž¡ï¸ Loading sample: ${sampleToLoad?.split('/').pop()}`);
    
    if (sampleToLoad && tracks.length > instrumentIndex) {
      audioEngineRef.current.loadSample(sampleToLoad).then(() => {
        audioEngineRef.current.updateSelectedSample(tracks[instrumentIndex].id, sampleToLoad);
        
        // ðŸŽ›ï¸ WICHTIG: Volume nach Sample-Wechsel synchronisieren
        const currentVolume = trackVolumes[instrumentIndex] || 75;
        audioEngineRef.current.updateVolume(tracks[instrumentIndex].id, currentVolume / 100);
        
        setTracks(prev => prev.map((track, index) => 
          index === instrumentIndex 
            ? { ...track, selectedSampleId: sampleToLoad }
            : track
        ));
        console.log(`âž¡ï¸ Next sample for ${instrument.name}: ${sampleToLoad.split('/').pop()} @ ${currentVolume}%`);
      }).catch(error => {
        console.error(`âŒ Failed to load next sample:`, error);
      });
    }
  }, [availablePacks, currentPackIndex, currentInstruments, sampleIndices, tracks]);
  
  // Test current sample
  const testCurrentSample = useCallback(() => {
    if (tracks.length > 0 && tracks[0].selectedSampleId) {
      const volume = masterVolume / 100;
      audioEngineRef.current.playSample(tracks[0].selectedSampleId, volume);
      console.log('ðŸ§ª Testing sample:', tracks[0].selectedSampleId);
    } else {
      // Fallback: play a simple beep for testing
      console.log('ðŸ§ª Testing fallback beep (no samples loaded)');
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 440;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3 * (masterVolume / 100), audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }
  }, [tracks, masterVolume]);

  // VISUAL UPDATE LOOP
  useEffect(() => {
    if (isPlaying) {
      const updateVisuals = () => {
        if (audioEngineRef.current && isPlaying) {
          setCurrentStep(audioEngineRef.current.getCurrentStep());
          visualUpdateRef.current = requestAnimationFrame(updateVisuals);
        }
      };
      updateVisuals();
    } else {
      if (visualUpdateRef.current) {
        cancelAnimationFrame(visualUpdateRef.current);
        visualUpdateRef.current = null;
      }
    }
    
    return () => {
      if (visualUpdateRef.current) {
        cancelAnimationFrame(visualUpdateRef.current);
      }
    };
  }, [isPlaying]);
  
  // Blueprint overlay for development
  const blueprintOverlay = useBlueprintOverlay();
  
  // QUANTIZATION PRESETS DEFINITION
  const quantizationPresets: QuantizationPreset[] = [
    { id: 'straight', name: 'Straight', description: 'Perfect timing - no swing' },
    { id: 'swing-light', name: 'Swing Light', description: 'Subtle swing feel' },
    { id: 'swing-medium', name: 'Swing Medium', description: 'Classic swing' },
    { id: 'swing-heavy', name: 'Swing Heavy', description: 'Heavy swing feel' },
    { id: 'shuffle', name: 'Shuffle', description: 'Triplet shuffle feel' },
    { id: 'j-dilla-1', name: 'J Dilla 1', description: 'Signature Dilla feel' },
    { id: 'j-dilla-2', name: 'J Dilla 2', description: 'Heavier Dilla groove' },
    { id: 'j-dilla-3', name: 'J Dilla 3', description: 'Extreme Dilla feel' },
    { id: 'laid-back', name: 'Laid Back', description: 'Relaxed, behind the beat' },
    { id: 'rushed', name: 'Rushed', description: 'Tight, ahead of the beat' },
    { id: 'funky', name: 'Funky', description: 'Funk groove feel' },
    { id: 'breakbeat', name: 'Breakbeat', description: 'Breakbeat timing' },
    { id: 'trap', name: 'Trap', description: 'Trap hi-hat feel' },
    { id: 'boom-bap', name: 'Boom Bap', description: '90s hip-hop feel' },
    { id: 'neo-soul', name: 'Neo Soul', description: 'Modern soul groove' }
  ];
  
  // LOAD SAMPLE FOR CURRENT INSTRUMENT
  useEffect(() => {
    if (availablePacks.length > 0 && tracks.length > 0) {
      handleInstrumentChange(currentInstrument);
    }
  }, [availablePacks, currentPackIndex, tracks.length]);

  if (isLoading) {
    return (
      <div className="soundangeles-drum-sequencer min-h-screen bg-white p-8 flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold text-black mb-4">SoundAngeles</h1>
          <p className="text-gray-600 mb-4">Initializing Professional Drum Sequencer...</p>
          <div className="animate-pulse">
            <div className="bg-gray-200 h-4 w-64 mx-auto rounded mb-4"></div>
            <div className="bg-gray-200 h-4 w-48 mx-auto rounded"></div>
          </div>
          <p className="text-sm text-gray-500 mt-4">Loading samples and audio engine...</p>
        </div>
      </div>
    );
  }

  return (
    <div 
      className={cn(
        "soundangeles-drum-sequencer",
        embedded ? "embedded-mode" : "standalone-mode"
      )}
      style={{
        backgroundColor: colors.background,
        color: colors.text,
        fontFamily: '"Poppins", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
        minHeight: embedded ? 'auto' : '100vh',
        padding: embedded ? '2rem' : '4rem 2rem',
      }}
    >
      {/* Main Container */}
      <div className="max-w-6xl mx-auto">
        


        {/* Main Control Panel - Responsive Container System */}
        <div 
          className="rounded-lg border mx-auto p-4 md:p-6 lg:p-8"
          style={{ 
            backgroundColor: colors.surface,
            borderColor: colors.border,
            borderWidth: '1px',
            maxWidth: '100%',
            minHeight: 'auto'
          }}
        >
          {/* RESPONSIVE CONTAINER SYSTEM - Mobile First with CSS Order */}
          <div className="flex flex-col lg:flex-row lg:justify-between gap-4 md:gap-6 lg:gap-8">
            
            {/* CONTAINER 1: LOGO - Mobile: order-1, Desktop: order-6 */}
            <div id="container-logo" className="order-1 lg:order-6 flex flex-col items-center lg:items-end">
              <div className="mb-2">
                <img 
                  src="/SoundAngelesLogo.svg" 
                  alt="Sound Angeles Logo" 
                  className="h-8 md:h-10 lg:h-12 w-auto"
                />
              </div>
              <p className="text-xs md:text-sm uppercase tracking-wider text-center lg:text-right" style={{ color: colors.textMuted }}>
                DRUM SEQUENZER
              </p>
            </div>

            {/* CONTAINER 2: SAMPLE PACK - Mobile: order-2, Desktop: order-2 */}
            <div id="container-sample-pack" className="order-2 flex flex-col items-center">
              {/* Pack Cover Image */}
              {availablePacks[currentPackIndex]?.coverImage && (
                <div className="relative inline-block mb-4">
                  <img
                    src={availablePacks[currentPackIndex].coverImage}
                    alt={`${availablePacks[currentPackIndex].name} cover`}
                    className="w-32 h-32 md:w-48 md:h-48 lg:w-64 lg:h-64 object-cover rounded-lg border-2"
                    style={{ border: `2px solid ${colors.border}` }}
                    onError={(e) => {
                      console.warn('Failed to load pack cover image');
                      e.currentTarget.style.display = 'none';
                    }}
                  />
                  <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm">
                    {Object.keys(availablePacks[currentPackIndex]?.categories || {}).length || 0} Categories
                  </div>
                </div>
              )}

              {/* Pack Title and Navigation */}
              <div className="flex items-center justify-center gap-4">
                <button
                  onClick={handlePrevPack}
                  className="p-2 hover:opacity-70 transition-opacity"
                  style={{ color: availablePacks.length > 0 ? colors.primary : colors.textMuted }}
                  disabled={availablePacks.length <= 1}
                  title="Previous sample pack"
                >
                  <ChevronLeft size={20} />
                </button>
                
                <div className="text-center min-w-[200px]">
                  <h3 className="font-semibold text-sm md:text-base">
                    {availablePacks[currentPackIndex]?.name || 'SoundAngeles Pack'}
                  </h3>
                  <p className="text-xs" style={{ color: colors.textMuted }}>
                    {availablePacks.length > 0 ? `${currentPackIndex + 1} / ${availablePacks.length}` : 'Ready'}
                  </p>
                </div>
                
                <button
                  onClick={handleNextPack}
                  className="p-2 hover:opacity-70 transition-opacity"
                  style={{ color: availablePacks.length > 0 ? colors.primary : colors.textMuted }}
                  disabled={availablePacks.length <= 1}
                  title="Next sample pack"
                >
                  <ChevronRight size={20} />
                </button>
              </div>
            </div>

            {/* CONTAINER 3: VOLUME - Mobile: order-3, Desktop: order-1 */}
            <div id="container-volume" className="order-3 lg:order-1 flex flex-col items-center lg:items-start">
              {/* Volume Label */}
              <div className="text-center mb-4">
                <p className="text-xs md:text-sm font-semibold tracking-widest uppercase" style={{ color: colors.text }}>
                  VOLUME
                </p>
              </div>
              
              {/* Master Volume Knob - Responsive */}
              <div className="flex justify-center lg:justify-start">
                <RotaryKnob
                  value={masterVolume}
                  onChange={handleVolumeChange}
                  size="big"
                  min={0}
                  max={100}
                />
              </div>
            </div>

            {/* CONTAINER 4: TRANSPORT - Mobile: order-4, Desktop: order-5 */}
            <div id="container-transport" className="order-4 lg:order-5 w-full">
              <div className="flex flex-col items-center gap-3">
                {/* Play/Clear Controls */}
                <div className="flex gap-2 md:gap-3">
                  <Button
                    onClick={handlePlayStop}
                    className="rounded-none font-semibold transition-all w-[100px] md:w-[120px]"
                    style={{
                      backgroundColor: isPlaying ? colors.primary : 'transparent',
                      color: isPlaying ? 'white' : colors.primary,
                      border: `2px solid ${colors.primary}`,
                      height: '48px'
                    }}
                  >
                    {isPlaying ? <Pause className="mr-2" size={16} /> : <Play className="mr-2" size={16} />}
                    {isPlaying ? 'STOP' : 'PLAY'}
                  </Button>
                  
                  <Button
                    onClick={handleClear}
                    className="rounded-none text-sm font-medium w-[100px] md:w-[120px]"
                    style={{
                      backgroundColor: 'transparent',
                      color: colors.text,
                      border: `1px solid ${colors.border}`,
                      height: '48px'
                    }}
                  >
                    Clear Pattern
                  </Button>
                </div>
                
                {/* Pattern Banks */}
                <div className="flex flex-col gap-2 items-center">
                  <div className="flex gap-2 md:gap-3 items-center">
                    {patternBanks.map((bank) => (
                      <Button
                        key={bank.id}
                        onClick={() => loadPatternFromBank(bank.id)}
                        className="w-12 h-8 md:w-14 md:h-9 rounded-none font-bold text-base md:text-lg"
                        style={{
                          backgroundColor: currentBankId === bank.id ? colors.primary : colors.surface,
                          color: currentBankId === bank.id ? 'white' : colors.text,
                          border: `2px solid ${currentBankId === bank.id ? colors.primary : colors.border}`,
                        }}
                        title={`Load Pattern ${bank.id}`}
                      >
                        {bank.id}
                      </Button>
                    ))}
                  </div>
                  
                  {/* Copy System */}
                  <div className="flex items-center gap-4">
                    <Button
                      onClick={() => copyPatternToBank('A', 'B')}
                      disabled={copyProgress['A-B']}
                      className="px-2 py-1 rounded-none font-medium text-xs"
                      style={{
                        backgroundColor: copyProgress['A-B'] ? colors.border : colors.surface,
                        color: copyProgress['A-B'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px'
                      }}
                    >
                      {copyProgress['A-B'] ? 'DONE âœ“' : 'COPY â†—'}
                    </Button>
                    
                    <Button
                      onClick={() => copyPatternToBank('B', 'C')}
                      disabled={copyProgress['B-C']}
                      className="px-2 py-1 rounded-none font-medium text-xs"
                      style={{
                        backgroundColor: copyProgress['B-C'] ? colors.border : colors.surface,
                        color: copyProgress['B-C'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px'
                      }}
                    >
                      {copyProgress['B-C'] ? 'WAIT' : 'COPY â†—'}
                    </Button>
                    
                    <Button
                      onClick={() => copyPatternToBank('C', 'D')}
                      disabled={copyProgress['C-D']}
                      className="px-2 py-1 rounded-none font-medium text-xs"
                      style={{
                        backgroundColor: copyProgress['C-D'] ? colors.border : colors.surface,
                        color: copyProgress['C-D'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px'
                      }}
                    >
                      {copyProgress['C-D'] ? 'WAIT' : 'COPY â†—'}
                    </Button>
                  </div>
                </div>
              </div>
            </div>

            {/* CONTAINER 5: QUANTIZATION - Mobile: order-5, Desktop: order-4 */}
            <div id="container-quantization" className="order-5 lg:order-4 w-full">
              <div className="grid grid-cols-2 md:grid-cols-5 gap-2">
                {['STRAIGHT', 'SLIGHT', 'SWING', 'HARD', 'TRIPLET'].map((preset, index) => {
                  const originalPresets = ['straight', 'swing-medium', 'j-dilla-1', 'shuffle', 'boom-bap'];
                  const presetId = originalPresets[index];
                  
                  return (
                    <Button
                      key={presetId}
                      onClick={() => handleQuantizationChange(presetId)}
                      className="px-3 py-2 rounded-none text-xs font-medium"
                      style={{
                        backgroundColor: currentGroovePreset === presetId ? colors.primary : colors.surface,
                        color: currentGroovePreset === presetId ? 'white' : colors.text,
                        border: `1px solid ${currentGroovePreset === presetId ? colors.primary : colors.border}`,
                        minWidth: '80px',
                        height: '48px'
                      }}
                    >
                      {preset}
                    </Button>
                  );
                })}
              </div>
            </div>

          </div>
        </div>

          {/* INSTRUMENTS Section - Fixed 8 Instruments Horizontally */}
          <div className="mb-3">
            {/* Instrument Groups - Volume Knob + WippSchalter pro Instrument */}
              <div className="text-center">
                {/* Pack Cover Image - FIRST and DOUBLE SIZE */}
                {availablePacks[currentPackIndex]?.coverImage && (
                  <div className="relative inline-block mb-4">
                    <img
                      src={availablePacks[currentPackIndex].coverImage}
                      alt={`${availablePacks[currentPackIndex].name} cover`}
                      className="w-64 h-64 object-cover rounded-lg border-2"
                      style={{ border: `2px solid ${colors.border}` }}
                      onError={(e) => {
                        console.warn('Failed to load pack cover image');
                        e.currentTarget.style.display = 'none';
                      }}
                    />
                    <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm">
                      {Object.keys(availablePacks[currentPackIndex]?.categories || {}).length || 0} Categories
                    </div>
                  </div>
                )}

                {/* Pack Title and Navigation - BELOW COVER */}
                <div className="flex items-center justify-center gap-4">
                  <button
                    onClick={handlePrevPack}
                    className="p-2 hover:opacity-70 transition-opacity"
                    style={{ color: availablePacks.length > 0 ? colors.primary : colors.textMuted }}
                    disabled={availablePacks.length <= 1}
                    title="Previous sample pack"
                  >
                    <ChevronLeft size={20} />
                  </button>
                  
                  <div className="text-center min-w-[200px]">
                    <h3 className="font-semibold text-base">
                      {availablePacks[currentPackIndex]?.name || 'SoundAngeles Pack'}
                    </h3>
                    <p className="text-xs" style={{ color: colors.textMuted }}>
                      {availablePacks.length > 0 ? `${currentPackIndex + 1} / ${availablePacks.length}` : 'Ready'}
                    </p>
                  </div>
                  
                  <button
                    onClick={handleNextPack}
                    className="p-2 hover:opacity-70 transition-opacity"
                    style={{ color: availablePacks.length > 0 ? colors.primary : colors.textMuted }}
                    disabled={availablePacks.length <= 1}
                    title="Next sample pack"
                  >
                    <ChevronRight size={20} />
                  </button>
                </div>
              </div>
            </div>
            
            {/* RIGHT COLUMN - Controls & Pattern Banks (Blocks 3-5) */}
            <div className="flex flex-col items-center lg:items-end space-y-6">
              
              {/* Block 3 - Branding */}
              <div className="flex flex-col items-center lg:items-end">
                {/* Sound Angeles Logo */}
                <div className="mb-2">
                  <img 
                    src="/SoundAngelesLogo.svg" 
                    alt="Sound Angeles Logo" 
                    className="h-12 w-auto"
                  />
                </div>
                <p className="text-sm uppercase tracking-wider" style={{ color: colors.textMuted }}>
                  DRUM SEQUENZER
                </p>
              </div>
              
            </div>
          </div>

          {/* Quantization Controls + Transport Section - Same Level */}
          <div className="mb-6" style={{ backgroundColor: colors.surface, padding: '16px 16px 16px 0px' }}>
            <div className="flex items-end justify-between mb-4">
              {/* Left side: Quantization buttons - shifted left by 10px */}
              <div className="grid grid-cols-5 gap-2" style={{ width: 'fit-content' }}>
                {['STRAIGHT', 'SLIGHT', 'SWING', 'HARD', 'TRIPLET'].map((preset, index) => {
                  // Map to original preset IDs for functionality
                  const originalPresets = ['straight', 'swing-medium', 'j-dilla-1', 'shuffle', 'boom-bap'];
                  const presetId = originalPresets[index];
                  const descriptions = [
                    'Keine Verschiebung',
                    'Minimaler Swing', 
                    'Standard Swing Feel',
                    'Starker Swing',
                    'Triolenfeel (67% Swing)'
                  ];
                  
                  return (
                    <Button
                      key={presetId}
                      onClick={() => handleQuantizationChange(presetId)}
                      className="px-3 py-2 rounded-none text-xs font-medium"
                      style={{
                        backgroundColor: currentGroovePreset === presetId ? colors.primary : colors.surface,
                        color: currentGroovePreset === presetId ? 'white' : colors.text,
                        border: `1px solid ${currentGroovePreset === presetId ? colors.primary : colors.border}`,
                        minWidth: '80px',
                        height: '48px'
                      }}
                      title={descriptions[index]}
                    >
                      {preset}
                    </Button>
                  );
                })}
              </div>
              
              {/* TRANSPORT SECTION - Play/Clear + Pattern Banks + Copy System */}
              <div className="flex flex-col items-center">
                
                {/* Play/Clear Controls - exact width match with bank buttons */}
                <div className="flex gap-2 md:gap-3 mb-3">
                  {/* Play Button - exactly half of 4 Bank buttons width */}
                  <Button
                    onClick={handlePlayStop}
                    className="rounded-none font-semibold transition-all w-[100px] md:w-[120px]"
                    style={{
                      backgroundColor: isPlaying ? colors.primary : 'transparent',
                      color: isPlaying ? 'white' : colors.primary,
                      border: `2px solid ${colors.primary}`,
                      height: '48px'
                    }}
                  >
                    {isPlaying ? <Pause className="mr-2" size={16} /> : <Play className="mr-2" size={16} />}
                    {isPlaying ? 'STOP' : 'PLAY'}
                  </Button>
                  
                  {/* Clear Pattern Button - exactly half of 4 Bank buttons width */}
                  <Button
                    onClick={handleClear}
                    className="rounded-none text-sm font-medium w-[100px] md:w-[120px]"
                    style={{
                      backgroundColor: 'transparent',
                      color: colors.text,
                      border: `1px solid ${colors.border}`,
                      height: '48px'
                    }}
                  >
                    Clear Pattern
                  </Button>
                </div>
                
                {/* Pattern Banks with Visual Copy System */}
                <div className="flex flex-col gap-2 items-center">
                  {/* Bank Buttons - Top Row */}
                  <div className="flex gap-2 md:gap-3 items-center">
                    {patternBanks.map((bank) => (
                      <Button
                        key={bank.id}
                        onClick={() => loadPatternFromBank(bank.id)}
                        className="w-12 h-8 md:w-14 md:h-9 rounded-none font-bold text-base md:text-lg"
                        style={{
                          backgroundColor: currentBankId === bank.id ? colors.primary : colors.surface,
                          color: currentBankId === bank.id ? 'white' : colors.text,
                          border: `2px solid ${currentBankId === bank.id ? colors.primary : colors.border}`,
                        }}
                        title={`Load Pattern ${bank.id}`}
                      >
                        {bank.id}
                      </Button>
                    ))}
                  </div>
                  
                  {/* Copy Buttons - Bottom Row - SEQUENTIAL COPY SYSTEM */}
                  <div className="flex items-center" style={{ 
                    width: '100%', 
                    maxWidth: '280px',
                    justifyContent: 'space-evenly',
                    paddingLeft: '40px',
                    paddingRight: '40px'
                  }}>
                    {/* A â†’ B - Always enabled first */}
                    <Button
                      onClick={() => copyPatternToBank('A', 'B')}
                      disabled={copyProgress['A-B']}
                      className="px-2 py-1 rounded-none font-medium text-xs flex items-center justify-center"
                      style={{
                        backgroundColor: copyProgress['A-B'] ? colors.border : colors.surface,
                        color: copyProgress['A-B'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px',
                        opacity: copyProgress['A-B'] ? 0.5 : 1,
                        cursor: copyProgress['A-B'] ? 'not-allowed' : 'pointer'
                      }}
                      title={copyProgress['A-B'] ? "Aâ†’B already completed" : "Copy A to B and switch to Bank B"}
                    >
                      {copyProgress['A-B'] ? 'DONE âœ“' : 'COPY â†—'}
                    </Button>
                    
                    {/* B â†’ C - Enabled after Aâ†’B */}
                    <Button
                      onClick={() => copyPatternToBank('B', 'C')}
                      disabled={copyProgress['B-C']}
                      className="px-2 py-1 rounded-none font-medium text-xs flex items-center justify-center"
                      style={{
                        backgroundColor: copyProgress['B-C'] ? colors.border : colors.surface,
                        color: copyProgress['B-C'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px',
                        opacity: copyProgress['B-C'] ? 0.5 : 1,
                        cursor: copyProgress['B-C'] ? 'not-allowed' : 'pointer'
                      }}
                      title={copyProgress['B-C'] ? "Complete Aâ†’B first" : "Copy B to C and switch to Bank C"}
                    >
                      {copyProgress['B-C'] ? 'WAIT' : 'COPY â†—'}
                    </Button>
                    
                    {/* C â†’ D - Enabled after Bâ†’C */}
                    <Button
                      onClick={() => copyPatternToBank('C', 'D')}
                      disabled={copyProgress['C-D']}
                      className="px-2 py-1 rounded-none font-medium text-xs flex items-center justify-center"
                      style={{
                        backgroundColor: copyProgress['C-D'] ? colors.border : colors.surface,
                        color: copyProgress['C-D'] ? colors.textMuted : colors.text,
                        border: `1px solid ${colors.border}`,
                        minWidth: '50px',
                        height: '24px',
                        opacity: copyProgress['C-D'] ? 0.5 : 1,
                        cursor: copyProgress['C-D'] ? 'not-allowed' : 'pointer'
                      }}
                      title={copyProgress['C-D'] ? "Complete Bâ†’C first" : "Copy C to D and switch to Bank D"}
                    >
                      {copyProgress['C-D'] ? 'WAIT' : 'COPY â†—'}
                    </Button>
                  </div>
                </div>
              </div>
            </div>

          </div>
        </div>

        {/* INSTRUMENTS Section - Fixed 8 Instruments Horizontally */}
        <div className="mb-3">
          {/* Instrument Groups - Volume Knob + WippSchalter pro Instrument */}
          <div className="grid grid-cols-4 md:grid-cols-8 gap-2">
              {currentInstruments.map((inst, idx) => (
                <div key={`instrument-group-${idx}`} className="flex flex-col items-center">
                  {/* Volume Knob mit Prozent-Anzeige */}
                  <div className="relative mb-3">
                    <RotaryKnob
                      value={trackVolumes[idx]}
                      onChange={(volume) => handleTrackVolumeChange(idx, volume)}
                      size="mid"
                      min={0}
                      max={100}
                    />
                    {/* Prozentanzeige links oben neben dem Knob */}
                    <span className="absolute -top-1 -left-3 text-xs" style={{ color: colors.textMuted }}>
                      {trackVolumes[idx]}%
                    </span>
                  </div>
                  
                  {/* WippSchalter direkt unter dem Volume Knob */}
                  <div className="flex justify-center">
                    <InstrumentWippSchalter
                      instrumentName={inst.name}
                      currentSampleIndex={sampleIndices[idx] || 0}
                      totalSamples={inst.hasSamples ? availablePacks[currentPackIndex]?.categories?.[inst.originalCategory]?.samples?.length || 1 : 1}
                      isActive={currentInstrument === idx}
                      onPreviousSample={() => handlePreviousSample(idx)}
                      onNextSample={() => handleNextSample(idx)}
                      onSelect={() => handleInstrumentChange(idx)}
                    />
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Desktop: Alle 16 Pads horizontal | Tablet/Mobile: 4er-Takt-Gruppen */}
          <div className="hidden lg:block mb-2">
            {/* Desktop Layout - Alle 16 horizontal wie vorher */}
            {/* LED-Laufleiste */}
            <div className="flex justify-start gap-2 mb-1">
              {Array.from({ length: 16 }, (_, i) => (
                <div
                  key={i}
                  className="w-[52px] md:w-[60px] h-1 transition-all"
                  style={{
                    backgroundColor: i === currentStep && isPlaying ? colors.primary : colors.border,
                  }}
                />
              ))}
            </div>
            
            {/* 16 Pads horizontal */}
            <div className="flex justify-start gap-2">
              {Array.from({ length: 16 }, (_, step) => {
                const isActive = tracks[currentInstrument]?.steps[step] || false;
                const isCurrentStep = step === currentStep && isPlaying;
                
                return (
                  <div
                    key={step}
                    onClick={() => toggleStep(step)}
                    className="w-[52px] h-[52px] md:w-[60px] md:h-[60px] relative cursor-pointer transition-all hover:scale-105"
                    style={{
                      boxShadow: isCurrentStep ? `0 0 10px ${colors.primary}` : 'none',
                    }}
                    title={`Step ${step + 1} - Click to ${isActive ? 'deactivate' : 'activate'}`}
                  >
                    <img
                      src={isActive ? '/ui-elements/pads/pad_on_2.png' : '/ui-elements/pads/pad_off_2.png'}
                      alt={`Pad ${step + 1}`}
                      className="w-full h-full object-contain"
                      draggable={false}
                    />
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* Tablet Layout - 2x8er Gruppen */}
          <div className="hidden md:block lg:hidden space-y-4 mb-2">
            {Array.from({ length: 2 }, (_, groupIndex) => {
              const startStep = groupIndex * 8;
              const stepsInGroup = 8;
              
              return (
                <div key={`tablet-group-${groupIndex}`} className="flex flex-col">
                  {/* LED-Laufleiste fÃ¼r 8 Steps */}
                  <div className="flex justify-between gap-2 mb-2">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      return (
                        <div
                          key={globalStep}
                          className="flex-1 h-1 transition-all"
                          style={{
                            backgroundColor: globalStep === currentStep && isPlaying ? colors.primary : colors.border,
                          }}
                        />
                      );
                    })}
                  </div>
                  
                  {/* 8 Pads fÃ¼r diese Gruppe */}
                  <div className="flex justify-between gap-2 mb-2">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      const isActive = tracks[currentInstrument]?.steps[globalStep] || false;
                      const isCurrentStep = globalStep === currentStep && isPlaying;
                      
                      return (
                        <div
                          key={globalStep}
                          onClick={() => toggleStep(globalStep)}
                          className="flex-1 aspect-square relative cursor-pointer transition-all hover:scale-105 max-w-[85px]"
                          style={{
                            boxShadow: isCurrentStep ? `0 0 10px ${colors.primary}` : 'none',
                          }}
                          title={`Step ${globalStep + 1} - Click to ${isActive ? 'deactivate' : 'activate'}`}
                        >
                          <img
                            src={isActive ? '/ui-elements/pads/pad_on_2.png' : '/ui-elements/pads/pad_off_2.png'}
                            alt={`Pad ${globalStep + 1}`}
                            className="w-full h-full object-contain"
                            draggable={false}
                          />
                        </div>
                      );
                    })}
                  </div>
                  
                  {/* Step-Zahlen mit Beat Markers fÃ¼r 8 Steps */}
                  <div className="flex justify-between gap-2">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      const stepNumber = globalStep + 1;
                      const isBeatMarker = (globalStep % 4) === 0;
                      
                      return (
                        <div key={`tablet-step-${globalStep}`} className="flex-1 text-center flex flex-col items-center max-w-[85px]">
                          <div className="text-xs" style={{ color: colors.textMuted }}>
                            {stepNumber}
                          </div>
                          {isBeatMarker && (
                            <div className="w-1 h-1 rounded-full mt-0.5" style={{ backgroundColor: colors.primary }} />
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>

          {/* Mobile Layout - 4x4er Gruppen */}
          <div className="block md:hidden space-y-3 mb-2">
            {Array.from({ length: 4 }, (_, groupIndex) => {
              const startStep = groupIndex * 4;
              const stepsInGroup = 4;
              
              return (
                <div key={`mobile-group-${groupIndex}`} className="flex flex-col">
                  {/* LED-Laufleiste fÃ¼r 4 Steps */}
                  <div className="flex justify-between gap-3 mb-3">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      return (
                        <div
                          key={globalStep}
                          className="flex-1 h-1 transition-all"
                          style={{
                            backgroundColor: globalStep === currentStep && isPlaying ? colors.primary : colors.border,
                          }}
                        />
                      );
                    })}
                  </div>
                  
                  {/* 4 Pads fÃ¼r diese Gruppe */}
                  <div className="flex justify-between gap-3 mb-3">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      const isActive = tracks[currentInstrument]?.steps[globalStep] || false;
                      const isCurrentStep = globalStep === currentStep && isPlaying;
                      
                      return (
                        <div
                          key={globalStep}
                          onClick={() => toggleStep(globalStep)}
                          className="flex-1 aspect-square relative cursor-pointer transition-all hover:scale-105 max-w-[120px]"
                          style={{
                            boxShadow: isCurrentStep ? `0 0 10px ${colors.primary}` : 'none',
                          }}
                          title={`Step ${globalStep + 1} - Click to ${isActive ? 'deactivate' : 'activate'}`}
                        >
                          <img
                            src={isActive ? '/ui-elements/pads/pad_on_2.png' : '/ui-elements/pads/pad_off_2.png'}
                            alt={`Pad ${globalStep + 1}`}
                            className="w-full h-full object-contain"
                            draggable={false}
                          />
                        </div>
                      );
                    })}
                  </div>
                  
                  {/* Step-Zahlen mit Beat Markers fÃ¼r 4 Steps */}
                  <div className="flex justify-between gap-3">
                    {Array.from({ length: stepsInGroup }, (_, localStep) => {
                      const globalStep = startStep + localStep;
                      const stepNumber = globalStep + 1;
                      const isBeatMarker = (globalStep % 4) === 0;
                      
                      return (
                        <div key={`mobile-step-${globalStep}`} className="flex-1 text-center flex flex-col items-center max-w-[120px]">
                          <div className="text-sm font-medium" style={{ color: colors.textMuted }}>
                            {stepNumber}
                          </div>
                          {isBeatMarker && (
                            <div className="w-1.5 h-1.5 rounded-full mt-1" style={{ backgroundColor: colors.primary }} />
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>
          

          {/* Step Numbers with Beat Markers - NUR FÃœR DESKTOP */}
          <div className="hidden lg:block">
            <div className="flex justify-start gap-2 mt-1">
              {Array.from({ length: 16 }, (_, i) => {
                const stepNumber = i + 1;
                const isBeatMarker = (i % 4) === 0; // 1, 5, 9, 13
                return (
                  <div
                    key={i}
                    className="w-[52px] md:w-[60px] text-center flex flex-col items-center"
                  >
                    {/* Step Number */}
                    <div 
                      className="text-xs"
                      style={{ color: colors.textMuted }}
                    >
                      {stepNumber}
                    </div>
                    {/* Beat Marker Circle - RED */}
                    {isBeatMarker && (
                      <div 
                        className="w-1 h-1 rounded-full mt-0.5"
                        style={{ backgroundColor: colors.primary }}
                      />
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          {/* Status Display centered below step numbers */}
          <div className="hidden lg:block text-center" style={{ marginTop: '25px' }}>
            <div className={`font-semibold text-sm`} style={{ color: isPlaying ? '#22c55e' : colors.primary }}>
              {isPlaying ? 'â— PLAYING' : 'â–  STOPPED'}
            </div>
          </div>

        </div>

        {/* Footer - Clean Copyright Only */}
        {!embedded && (
          <div className="text-center mt-8">
            <p className="text-sm" style={{ color: colors.textMuted }}>
              Â© 2025 SOUNDANGELESâ„¢
            </p>
          </div>
        )}
      </div>
    </div>
  );
}